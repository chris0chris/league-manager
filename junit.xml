<?xml version="1.0" encoding="utf-8"?><testsuites name="pytest tests"><testsuite name="pytest" errors="6" failures="7" skipped="0" tests="40" time="9.277" timestamp="2025-11-03T01:03:23.691427+01:00" hostname="delly"><testcase classname="gamedays.tests.api.test_game_views.TestRetrieveUpdateOfficials" name="test_create_officials" file="gamedays/tests/api/test_game_views.py" line="16" time="0.220" /><testcase classname="gamedays.tests.api.test_game_views.TestRetrieveUpdateOfficials" name="test_officials_get" file="gamedays/tests/api/test_game_views.py" line="37" time="0.027" /><testcase classname="gamedays.tests.api.test_game_views.TestRetrieveUpdateOfficials" name="test_officials_will_be_updated" file="gamedays/tests/api/test_game_views.py" line="26" time="0.034" /><testcase classname="gamedays.tests.api.test_game_views.TestGameSetup" name="test_game_setup_create" file="gamedays/tests/api/test_game_views.py" line="48" time="0.042" /><testcase classname="gamedays.tests.api.test_game_views.TestGameSetup" name="test_game_setup_get" file="gamedays/tests/api/test_game_views.py" line="80" time="0.024" /><testcase classname="gamedays.tests.api.test_game_views.TestGameSetup" name="test_game_setup_not_found_" file="gamedays/tests/api/test_game_views.py" line="88" time="0.004" /><testcase classname="gamedays.tests.api.test_game_views.TestGameSetup" name="test_game_setup_update" file="gamedays/tests/api/test_game_views.py" line="61" time="0.033" /><testcase classname="gamedays.tests.api.test_game_views.TestGameLog" name="test_game_not_found_exception" file="gamedays/tests/api/test_game_views.py" line="95" time="0.018" /><testcase classname="gamedays.tests.api.test_game_views.TestGameLog" name="test_get_team_log" file="gamedays/tests/api/test_game_views.py" line="99" time="0.032" /><testcase classname="gamedays.tests.api.test_game_views.TestGameLog" name="test_post_team_log" file="gamedays/tests/api/test_game_views.py" line="108" time="0.050" /><testcase classname="gamedays.tests.api.test_game_views.TestGameLog" name="test_post_team_log_change_of_possession" file="gamedays/tests/api/test_game_views.py" line="157" time="0.043" /><testcase classname="gamedays.tests.api.test_game_views.TestGameLog" name="test_post_team_log_updates_score" file="gamedays/tests/api/test_game_views.py" line="180" time="0.048" /><testcase classname="gamedays.tests.api.test_game_views.TestGameLog" name="test_post_team_log_with_empty_pat" file="gamedays/tests/api/test_game_views.py" line="131" time="0.045" /><testcase classname="gamedays.tests.api.test_game_views.TestGameLog" name="test_score_is_updated_with_multiple_entries" file="gamedays/tests/api/test_game_views.py" line="195" time="0.107" /><testcase classname="gamedays.tests.api.test_game_views.TestGameLog" name="test_team_log_entry_is_deleted" file="gamedays/tests/api/test_game_views.py" line="223" time="0.031" /><testcase classname="gamedays.tests.api.test_game_views.TestGameHalftime" name="test_halftime_submitted" file="gamedays/tests/api/test_game_views.py" line="235" time="0.041" /><testcase classname="gamedays.tests.api.test_game_views.TestGameFinalize" name="test_game_is_finalized" file="gamedays/tests/api/test_game_views.py" line="247" time="0.076" /><testcase classname="gamedays.tests.api.test_game_views.TestConfigPenaltiesAPIView" name="test_get_penalty_list" file="gamedays/tests/api/test_game_views.py" line="269" time="0.012" /><testcase classname="gamedays.tests.api.test_game_views.TestGamePossessionAPIView" name="test_put_game_possession" file="gamedays/tests/api/test_game_views.py" line="276" time="0.039" /><testcase classname="gamedays.tests.api.test_manager_serializers.TestLeagueManagerSerializer" name="test_serialize_league_manager" file="gamedays/tests/api/test_manager_serializers.py" line="31" time="0.237"><error message="failed on setup with &quot;TypeError: League() got unexpected keyword arguments: 'description'&quot;">self = &lt;test_manager_serializers.TestLeagueManagerSerializer object at 0x74fa668bc410&gt;

    def setup_method(self):
        self.user = User.objects.create_user(username='test', password='test123')
&gt;       self.league = League.objects.create(name='Test League', description='Test League Desc')
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

gamedays/tests/api/test_manager_serializers.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;League: Test League&gt;, args = (), kwargs = {'description': 'Test League Desc'}
cls = &lt;class 'gamedays.models.League'&gt;, opts = &lt;Options for League&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x74fa65b95930&gt;, val = 'Test League'
field = &lt;django.db.models.fields.CharField: name&gt;, is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: League() got unexpected keyword arguments: 'description'

../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/base.py:569: TypeError</error></testcase><testcase classname="gamedays.tests.api.test_manager_serializers.TestLeagueManagerSerializer" name="test_serialize_league_manager_without_season" file="gamedays/tests/api/test_manager_serializers.py" line="50" time="0.239"><error message="failed on setup with &quot;TypeError: League() got unexpected keyword arguments: 'description'&quot;">self = &lt;test_manager_serializers.TestLeagueManagerSerializer object at 0x74fa668bc690&gt;

    def setup_method(self):
        self.user = User.objects.create_user(username='test', password='test123')
&gt;       self.league = League.objects.create(name='Test League', description='Test League Desc')
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

gamedays/tests/api/test_manager_serializers.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;League: Test League&gt;, args = (), kwargs = {'description': 'Test League Desc'}
cls = &lt;class 'gamedays.models.League'&gt;, opts = &lt;Options for League&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x74fa65b97490&gt;, val = 'Test League'
field = &lt;django.db.models.fields.CharField: name&gt;, is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: League() got unexpected keyword arguments: 'description'

../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/base.py:569: TypeError</error></testcase><testcase classname="gamedays.tests.api.test_manager_serializers.TestLeagueManagerSerializer" name="test_create_league_manager_valid" file="gamedays/tests/api/test_manager_serializers.py" line="65" time="0.238"><error message="failed on setup with &quot;TypeError: League() got unexpected keyword arguments: 'description'&quot;">self = &lt;test_manager_serializers.TestLeagueManagerSerializer object at 0x74fa66dccb00&gt;

    def setup_method(self):
        self.user = User.objects.create_user(username='test', password='test123')
&gt;       self.league = League.objects.create(name='Test League', description='Test League Desc')
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

gamedays/tests/api/test_manager_serializers.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;League: Test League&gt;, args = (), kwargs = {'description': 'Test League Desc'}
cls = &lt;class 'gamedays.models.League'&gt;, opts = &lt;Options for League&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x74fa65b967d0&gt;, val = 'Test League'
field = &lt;django.db.models.fields.CharField: name&gt;, is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: League() got unexpected keyword arguments: 'description'

../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/base.py:569: TypeError</error></testcase><testcase classname="gamedays.tests.api.test_manager_serializers.TestLeagueManagerSerializer" name="test_create_league_manager_invalid_user" file="gamedays/tests/api/test_manager_serializers.py" line="81" time="0.225"><error message="failed on setup with &quot;TypeError: League() got unexpected keyword arguments: 'description'&quot;">self = &lt;test_manager_serializers.TestLeagueManagerSerializer object at 0x74fa669dbe10&gt;

    def setup_method(self):
        self.user = User.objects.create_user(username='test', password='test123')
&gt;       self.league = League.objects.create(name='Test League', description='Test League Desc')
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

gamedays/tests/api/test_manager_serializers.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;League: Test League&gt;, args = (), kwargs = {'description': 'Test League Desc'}
cls = &lt;class 'gamedays.models.League'&gt;, opts = &lt;Options for League&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x74fa65b96c20&gt;, val = 'Test League'
field = &lt;django.db.models.fields.CharField: name&gt;, is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: League() got unexpected keyword arguments: 'description'

../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/base.py:569: TypeError</error></testcase><testcase classname="gamedays.tests.api.test_manager_serializers.TestLeagueManagerSerializer" name="test_create_league_manager_without_season" file="gamedays/tests/api/test_manager_serializers.py" line="95" time="0.231"><error message="failed on setup with &quot;TypeError: League() got unexpected keyword arguments: 'description'&quot;">self = &lt;test_manager_serializers.TestLeagueManagerSerializer object at 0x74fa66a66330&gt;

    def setup_method(self):
        self.user = User.objects.create_user(username='test', password='test123')
&gt;       self.league = League.objects.create(name='Test League', description='Test League Desc')
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

gamedays/tests/api/test_manager_serializers.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;League: Test League&gt;, args = (), kwargs = {'description': 'Test League Desc'}
cls = &lt;class 'gamedays.models.League'&gt;, opts = &lt;Options for League&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x74fa65b970d0&gt;, val = 'Test League'
field = &lt;django.db.models.fields.CharField: name&gt;, is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: League() got unexpected keyword arguments: 'description'

../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/base.py:569: TypeError</error></testcase><testcase classname="gamedays.tests.api.test_manager_serializers.TestLeagueManagerSerializer" name="test_create_league_manager_invalid_season" file="gamedays/tests/api/test_manager_serializers.py" line="108" time="0.228"><error message="failed on setup with &quot;TypeError: League() got unexpected keyword arguments: 'description'&quot;">self = &lt;test_manager_serializers.TestLeagueManagerSerializer object at 0x74fa66e6f130&gt;

    def setup_method(self):
        self.user = User.objects.create_user(username='test', password='test123')
&gt;       self.league = League.objects.create(name='Test League', description='Test League Desc')
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

gamedays/tests/api/test_manager_serializers.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;League: Test League&gt;, args = (), kwargs = {'description': 'Test League Desc'}
cls = &lt;class 'gamedays.models.League'&gt;, opts = &lt;Options for League&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x74fa65b96800&gt;, val = 'Test League'
field = &lt;django.db.models.fields.CharField: name&gt;, is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: League() got unexpected keyword arguments: 'description'

../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/base.py:569: TypeError</error></testcase><testcase classname="gamedays.tests.api.test_manager_serializers.TestGamedayManagerSerializer" name="test_serialize_gameday_manager" file="gamedays/tests/api/test_manager_serializers.py" line="131" time="0.251"><failure message="AttributeError: 'str' object has no attribute 'isoformat'. Did you mean: 'format'?">self = &lt;test_manager_serializers.TestGamedayManagerSerializer object at 0x74fa668bc550&gt;

    def test_serialize_gameday_manager(self):
        """Test serializing a gameday manager"""
        gm = GamedayManager.objects.create(
            user=self.user,
            gameday=self.gameday,
            can_edit_details=True,
            can_assign_officials=False,
            can_manage_scores=True,
            assigned_by=self.user
        )
    
        serializer = GamedayManagerSerializer(gm)
&gt;       data = serializer.data
               ^^^^^^^^^^^^^^^

gamedays/tests/api/test_manager_serializers.py:144: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/rest_framework/serializers.py:573: in data
    ret = super().data
          ^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/rest_framework/serializers.py:251: in data
    self._data = self.to_representation(self.instance)
                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/rest_framework/serializers.py:540: in to_representation
    ret[field.field_name] = field.to_representation(attribute)
                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/rest_framework/fields.py:1870: in to_representation
    return method(value)
           ^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = GamedayManagerSerializer(&lt;GamedayManager: test -&gt; Test Spieltag&gt;):
    id = IntegerField(label='ID', read_only=True)
 ...ssigned_by = PrimaryKeyRelatedField(allow_null=True, read_only=True)
    assigned_by_username = SerializerMethodField()
obj = &lt;GamedayManager: test -&gt; Test Spieltag&gt;

    def get_gameday_date(self, obj):
&gt;       return obj.gameday.date.isoformat() if obj.gameday else None
               ^^^^^^^^^^^^^^^^^^^^^^^^^^
E       AttributeError: 'str' object has no attribute 'isoformat'. Did you mean: 'format'?

gamedays/api/serializers.py:242: AttributeError</failure></testcase><testcase classname="gamedays.tests.api.test_manager_serializers.TestGamedayManagerSerializer" name="test_create_gameday_manager_valid" file="gamedays/tests/api/test_manager_serializers.py" line="153" time="0.250" /><testcase classname="gamedays.tests.api.test_manager_serializers.TestGamedayManagerSerializer" name="test_create_gameday_manager_invalid_user" file="gamedays/tests/api/test_manager_serializers.py" line="173" time="0.266" /><testcase classname="gamedays.tests.api.test_manager_serializers.TestGamedayManagerSerializer" name="test_create_gameday_manager_defaults" file="gamedays/tests/api/test_manager_serializers.py" line="186" time="0.263" /><testcase classname="gamedays.tests.api.test_manager_serializers.TestGamedayManagerSerializer" name="test_update_gameday_manager_permissions" file="gamedays/tests/api/test_manager_serializers.py" line="202" time="0.272" /><testcase classname="gamedays.tests.api.test_manager_serializers.TestTeamManagerSerializer" name="test_serialize_team_manager" file="gamedays/tests/api/test_manager_serializers.py" line="234" time="0.245"><failure message="KeyError: 'user_id'">self = &lt;test_manager_serializers.TestTeamManagerSerializer object at 0x74fa668bce10&gt;

    def test_serialize_team_manager(self):
        """Test serializing a team manager"""
        tm = TeamManager.objects.create(
            user=self.user,
            team=self.team,
            can_edit_roster=True,
            can_submit_passcheck=False,
            assigned_by=self.user
        )
    
        serializer = TeamManagerSerializer(tm)
        data = serializer.data
    
&gt;       assert data['user_id'] == self.user.pk
               ^^^^^^^^^^^^^^^
E       KeyError: 'user_id'

gamedays/tests/api/test_manager_serializers.py:248: KeyError</failure></testcase><testcase classname="gamedays.tests.api.test_manager_serializers.TestTeamManagerSerializer" name="test_create_team_manager_valid" file="gamedays/tests/api/test_manager_serializers.py" line="254" time="0.243" /><testcase classname="gamedays.tests.api.test_manager_serializers.TestTeamManagerSerializer" name="test_create_team_manager_invalid_user" file="gamedays/tests/api/test_manager_serializers.py" line="272" time="0.239" /><testcase classname="gamedays.tests.api.test_manager_serializers.TestTeamManagerSerializer" name="test_create_team_manager_defaults" file="gamedays/tests/api/test_manager_serializers.py" line="285" time="0.237" /><testcase classname="gamedays.tests.api.test_manager_serializers.TestTeamManagerSerializer" name="test_update_team_manager_permissions" file="gamedays/tests/api/test_manager_serializers.py" line="300" time="0.244" /><testcase classname="gamedays.tests.api.test_manager_views.TestLeagueManagerAPI" name="test_create_league_manager_as_non_staff_forbidden" file="gamedays/tests/api/test_manager_views.py" line="75" time="0.457"><failure message="TypeError: League() got unexpected keyword arguments: 'description'">self = &lt;test_manager_views.TestLeagueManagerAPI testMethod=test_create_league_manager_as_non_staff_forbidden&gt;

    def setUp(self):
        self.staff_user = User.objects.create_user(
            username='staff', password='test123', is_staff=True
        )
        self.regular_user = User.objects.create_user(
            username='regular', password='test123'
        )
&gt;       self.league = League.objects.create(name='Test League', description='Test League Desc')
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

gamedays/tests/api/test_manager_views.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;League: Test League&gt;, args = (), kwargs = {'description': 'Test League Desc'}
cls = &lt;class 'gamedays.models.League'&gt;, opts = &lt;Options for League&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x74fa65ae3910&gt;, val = 'Test League'
field = &lt;django.db.models.fields.CharField: name&gt;, is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: League() got unexpected keyword arguments: 'description'

../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/base.py:569: TypeError</failure></testcase><testcase classname="gamedays.tests.api.test_manager_views.TestLeagueManagerAPI" name="test_create_league_manager_as_staff" file="gamedays/tests/api/test_manager_views.py" line="61" time="0.479"><failure message="TypeError: League() got unexpected keyword arguments: 'description'">self = &lt;test_manager_views.TestLeagueManagerAPI testMethod=test_create_league_manager_as_staff&gt;

    def setUp(self):
        self.staff_user = User.objects.create_user(
            username='staff', password='test123', is_staff=True
        )
        self.regular_user = User.objects.create_user(
            username='regular', password='test123'
        )
&gt;       self.league = League.objects.create(name='Test League', description='Test League Desc')
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

gamedays/tests/api/test_manager_views.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;League: Test League&gt;, args = (), kwargs = {'description': 'Test League Desc'}
cls = &lt;class 'gamedays.models.League'&gt;, opts = &lt;Options for League&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x74fa65ae3370&gt;, val = 'Test League'
field = &lt;django.db.models.fields.CharField: name&gt;, is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: League() got unexpected keyword arguments: 'description'

../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/base.py:569: TypeError</failure></testcase><testcase classname="gamedays.tests.api.test_manager_views.TestLeagueManagerAPI" name="test_delete_league_manager_as_staff" file="gamedays/tests/api/test_manager_views.py" line="89" time="0.470"><failure message="TypeError: League() got unexpected keyword arguments: 'description'">self = &lt;test_manager_views.TestLeagueManagerAPI testMethod=test_delete_league_manager_as_staff&gt;

    def setUp(self):
        self.staff_user = User.objects.create_user(
            username='staff', password='test123', is_staff=True
        )
        self.regular_user = User.objects.create_user(
            username='regular', password='test123'
        )
&gt;       self.league = League.objects.create(name='Test League', description='Test League Desc')
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

gamedays/tests/api/test_manager_views.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;League: Test League&gt;, args = (), kwargs = {'description': 'Test League Desc'}
cls = &lt;class 'gamedays.models.League'&gt;, opts = &lt;Options for League&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x74fa65ae3a90&gt;, val = 'Test League'
field = &lt;django.db.models.fields.CharField: name&gt;, is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: League() got unexpected keyword arguments: 'description'

../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/base.py:569: TypeError</failure></testcase><testcase classname="gamedays.tests.api.test_manager_views.TestLeagueManagerAPI" name="test_delete_league_manager_not_found" file="gamedays/tests/api/test_manager_views.py" line="106" time="0.458"><failure message="TypeError: League() got unexpected keyword arguments: 'description'">self = &lt;test_manager_views.TestLeagueManagerAPI testMethod=test_delete_league_manager_not_found&gt;

    def setUp(self):
        self.staff_user = User.objects.create_user(
            username='staff', password='test123', is_staff=True
        )
        self.regular_user = User.objects.create_user(
            username='regular', password='test123'
        )
&gt;       self.league = League.objects.create(name='Test League', description='Test League Desc')
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

gamedays/tests/api/test_manager_views.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;League: Test League&gt;, args = (), kwargs = {'description': 'Test League Desc'}
cls = &lt;class 'gamedays.models.League'&gt;, opts = &lt;Options for League&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x74fa65ae39d0&gt;, val = 'Test League'
field = &lt;django.db.models.fields.CharField: name&gt;, is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: League() got unexpected keyword arguments: 'description'

../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/base.py:569: TypeError</failure></testcase><testcase classname="gamedays.tests.api.test_manager_views.TestLeagueManagerAPI" name="test_list_league_managers_as_non_staff_forbidden" file="gamedays/tests/api/test_manager_views.py" line="51" time="0.490"><failure message="TypeError: League() got unexpected keyword arguments: 'description'">self = &lt;test_manager_views.TestLeagueManagerAPI testMethod=test_list_league_managers_as_non_staff_forbidden&gt;

    def setUp(self):
        self.staff_user = User.objects.create_user(
            username='staff', password='test123', is_staff=True
        )
        self.regular_user = User.objects.create_user(
            username='regular', password='test123'
        )
&gt;       self.league = League.objects.create(name='Test League', description='Test League Desc')
                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

gamedays/tests/api/test_manager_views.py:32: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/manager.py:87: in manager_method
    return getattr(self.get_queryset(), name)(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/query.py:661: in create
    obj = self.model(**kwargs)
          ^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;League: Test League&gt;, args = (), kwargs = {'description': 'Test League Desc'}
cls = &lt;class 'gamedays.models.League'&gt;, opts = &lt;Options for League&gt;, _setattr = &lt;built-in function setattr&gt;
_DEFERRED = &lt;Deferred field&gt;, fields_iter = &lt;tuple_iterator object at 0x74fa65ae3850&gt;, val = 'Test League'
field = &lt;django.db.models.fields.CharField: name&gt;, is_related_object = False, property_names = frozenset({'pk'})

    def __init__(self, *args, **kwargs):
        # Alias some things as locals to avoid repeat global lookups
        cls = self.__class__
        opts = self._meta
        _setattr = setattr
        _DEFERRED = DEFERRED
        if opts.abstract:
            raise TypeError("Abstract models cannot be instantiated.")
    
        pre_init.send(sender=cls, args=args, kwargs=kwargs)
    
        # Set up the storage for instance state
        self._state = ModelState()
    
        # There is a rather weird disparity here; if kwargs, it's set, then args
        # overrides it. It should be one or the other; don't duplicate the work
        # The reason for the kwargs check is that standard iterator passes in by
        # args, and instantiation for iteration is 33% faster.
        if len(args) &gt; len(opts.concrete_fields):
            # Daft, but matches old exception sans the err msg.
            raise IndexError("Number of args exceeds number of fields")
    
        if not kwargs:
            fields_iter = iter(opts.concrete_fields)
            # The ordering of the zip calls matter - zip throws StopIteration
            # when an iter throws it. So if the first iter throws it, the second
            # is *not* consumed. We rely on this, so don't change the order
            # without changing the logic.
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
        else:
            # Slower, kwargs-ready version.
            fields_iter = iter(opts.fields)
            for val, field in zip(args, fields_iter):
                if val is _DEFERRED:
                    continue
                _setattr(self, field.attname, val)
                if kwargs.pop(field.name, NOT_PROVIDED) is not NOT_PROVIDED:
                    raise TypeError(
                        f"{cls.__qualname__}() got both positional and "
                        f"keyword arguments for field '{field.name}'."
                    )
    
        # Now we're left with the unprocessed fields that *must* come from
        # keywords, or default.
    
        for field in fields_iter:
            is_related_object = False
            # Virtual field
            if field.column is None or field.generated:
                continue
            if kwargs:
                if isinstance(field.remote_field, ForeignObjectRel):
                    try:
                        # Assume object instance was passed in.
                        rel_obj = kwargs.pop(field.name)
                        is_related_object = True
                    except KeyError:
                        try:
                            # Object instance wasn't passed in -- must be an ID.
                            val = kwargs.pop(field.attname)
                        except KeyError:
                            val = field.get_default()
                else:
                    try:
                        val = kwargs.pop(field.attname)
                    except KeyError:
                        # This is done with an exception rather than the
                        # default argument on pop because we don't want
                        # get_default() to be evaluated, and then not used.
                        # Refs #12057.
                        val = field.get_default()
            else:
                val = field.get_default()
    
            if is_related_object:
                # If we are passed a related instance, set it using the
                # field.name instead of field.attname (e.g. "user" instead of
                # "user_id") so that the object gets properly cached (and type
                # checked) by the RelatedObjectDescriptor.
                if rel_obj is not _DEFERRED:
                    _setattr(self, field.name, rel_obj)
            else:
                if val is not _DEFERRED:
                    _setattr(self, field.attname, val)
    
        if kwargs:
            property_names = opts._property_names
            unexpected = ()
            for prop, value in kwargs.items():
                # Any remaining kwargs must correspond to properties or virtual
                # fields.
                if prop in property_names:
                    if value is not _DEFERRED:
                        _setattr(self, prop, value)
                else:
                    try:
                        opts.get_field(prop)
                    except FieldDoesNotExist:
                        unexpected += (prop,)
                    else:
                        if value is not _DEFERRED:
                            _setattr(self, prop, value)
            if unexpected:
                unexpected_names = ", ".join(repr(n) for n in unexpected)
&gt;               raise TypeError(
                    f"{cls.__name__}() got unexpected keyword arguments: "
                    f"{unexpected_names}"
                )
E               TypeError: League() got unexpected keyword arguments: 'description'

../../.pyenv/versions/leaguesphere/lib/python3.14/site-packages/django/db/models/base.py:569: TypeError</failure></testcase><testcase time="0.000" /></testsuite></testsuites>